#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rg32f) readonly uniform image2D inputImage;

layout(binding = 1, rg32f) writeonly uniform image2D outputImage;

void main() {
    ivec2 texSize = imageSize(inputImage);
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);

    if (texCoord.x >= texSize.x || texCoord.y >= texSize.y) {
        return;
    }
    float kernel[17] = float[](0.005f, 0.011f, 0.021f, 0.033f, 0.048f, 0.065f, 0.082f, 0.097f, 
                               0.105f, 0.097f, 0.082f, 0.065f, 0.048f, 0.033f, 0.021f, 0.011f, 0.005f);
    
    vec2 horizontalBlur = vec2(0.0);
    vec2 verticalBlur = vec2(0.0);
    float kernelSumH = 0.0;
    float kernelSumV = 0.0;

    for (int i = -8; i <= 8; ++i) {
        ivec2 offsetH = texCoord + ivec2(i, 0);
        offsetH.x = clamp(offsetH.x, 0, texSize.x - 1);

        vec2 momentsH = imageLoad(inputImage, offsetH).rg;
        horizontalBlur += momentsH * kernel[i + 8];
        kernelSumH += kernel[i + 8];
    }

    for (int i = -8; i <= 8; ++i) {
        ivec2 offsetV = texCoord + ivec2(0, i);
        offsetV.y = clamp(offsetV.y, 0, texSize.y - 1);

        vec2 momentsV = imageLoad(inputImage, offsetV).rg;
        verticalBlur += momentsV * kernel[i + 8];
        kernelSumV += kernel[i + 8];
    }

    horizontalBlur /= kernelSumH;
    verticalBlur /= kernelSumV;

    vec2 combinedBlur = (horizontalBlur + verticalBlur) * 0.5;

    imageStore(outputImage, texCoord, vec4(combinedBlur, 0.0, 0.0));
}
